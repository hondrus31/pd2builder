Array.prototype.intersect=function(...e){for(const t of e)if(!Array.isArray(t))throw"This function only accepts Array objects!";return this.filter(t=>{let s=!0;for(let r=0;r<e.length&&s;r++)s=e[r].includes(t);return s})},Array.prototype.reverseMiddle=function(){const e=this.slice(1,this.length-1);for(let t=0;t<e.length;t+=2)[e[t],e[t+1]]=[e[t+1],e[t]];return[this[0],...e,this[this.length-1]]},String.prototype.toCamelCase=function(){return this.replace(/(_\w)/g,e=>e[1].toUpperCase())};class e{constructor(){throw new Error("This class isn't supposed to be initialized")}static resolveRequire(e,t,s){return s.get("system.requires."+e)({rep:{name:t}})}static setParams(...e){const t=new URLSearchParams(window.location.search);for(const[s,r]of e)t.set(s,r);return t}static makeState(e,t){return{lang:e,skills:t.skills.toJSON(),armor:t.armor,perkDeck:t.perkDeck,throwable:t.throwable,deployable:t.deployable,deployableSecondary:t.deployableSecondary}}static getNodeIndex(e,t=(()=>!0)){return[...e.parentNode.children].filter(t).indexOf(e)}static parentElement(e,t=1){let s=e;for(let e=0;e<t;e++)s=s.parentElement;return s}}class t extends Map{constructor(...e){super(...e),this.points=120}getTierPoints(e,t,s){let r=0;for(const[i,o]of this){const l=s.get(i);l.subtree===t&&l.tier===e&&(2===o.state?r+=l.ace+l.basic:r+=l.basic)}return r}getTiersToFloorPoints(e,t,s){let r=0;for(let i=0;i<=e;i++)r+=this.getTierPoints(i,t,s);return r}toJSON(){const e={};for(const[t,s]of this)e[t]=s;return e}}class s extends Map{fetchAll(){const e=[];for(const[t]of this)e.push(fetch(`./db/${t}.json`).then(e=>e.json()).then(e=>{if("skills"===t||"perk_cards"===t)for(const r in e)e[r].stats&&("skills"===t?(e[r].stats.basic&&s.processModifiers(...e[r].stats.basic),e[r].stats.ace&&s.processModifiers(...e[r].stats.ace)):s.processModifiers(...e[r].stats));this.set(t,new Map(Object.entries(e)))}));return Promise.all(e)}static processModifiers(...e){for(const t of e)if(t)if("number"==typeof t.value)t.multiply?t.exec=e=>e*t.value:t.exec=e=>e+t.value;else{const e=Function.apply({},[...t.arguments,`return (${t.value})`]);t.multiply?t.exec=(t,...s)=>t*e.apply({},s):t.exec=(t,...s)=>t+e.apply({},s)}}}class r{constructor(e){this.builder=e}Skill_Add(e){const t=this.builder.exp,s=t.skills.get(e),i=this.builder.dbs.get("skills").get(e),o=t.subtrees[i.subtree];if(s){if(t.skills.points-i.ace>=0)return o.points+=i.ace,t.skills.points-=i.ace,s.state=2,o.tier=r.getSubtreeTierLevel(o.points),!0}else if(t.skills.points-i.basic>=0)return o.points+=i.basic,t.skills.points-=i.basic,t.skills.set(e,{state:1}),o.tier=r.getSubtreeTierLevel(o.points),!0;return!1}Skill_Remove(e){const t=this.builder.exp,s=t.skills.get(e),i=this.builder.dbs.get("skills"),o=i.get(e);if(!s)return!1;for(let e=o.tier;e<4;e++)if(0!==t.skills.getTierPoints(e+1,o.subtree,i)){const r=t.skills.getTiersToFloorPoints(e,o.subtree,i);if(2===s.state){if(r-o.ace<this.constructor.TIER_UTIL[e])return!1}else if(r-o.basic<this.constructor.TIER_UTIL[e])return!1}const l=t.subtrees[o.subtree];return 2===s.state?(l.points-=o.ace,t.skills.points+=o.ace,s.state=1):1===s.state&&(l.points-=o.basic,t.skills.points+=o.basic,t.skills.delete(e)),l.tier=r.getSubtreeTierLevel(l.points),!0}static getSubtreeTierLevel(e){let t=this.TIER_UTIL.findIndex(t=>e<=t);return-1===t&&(t=this.TIER_UTIL.length),t}}r.TIER_UTIL=[0,1,3,16];export{e as default,t as SkillMap,s as DBMap,r as System};export const{querySelector:$,querySelectorAll:$$,getElementById:$i,getElementsByClassName:$c,getElementsByTagName:$t}=document;
